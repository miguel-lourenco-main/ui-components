/** Generates a string of specified length filled with 'x' characters. */
export function dummyString(length: number = 10): string {
  return 'x'.repeat(length);
}

/** Generates a random number between specified min and max values. */
export function dummyNumber(min: number = 0, max: number = 100): number {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

/** Creates an array of specified length, filling it with generated elements. */
export function dummyArray<T>(length: number, generator: (index: number) => T): T[] {
  return Array.from({ length }, (_, i) => generator(i));
}

/** Creates an object with specified keys and dummy values. */
export function dummyObject(keys: string[]): Record<string, any> {
  const obj: Record<string, any> = {};
  keys.forEach(key => {
    obj[key] = `value_${key}`;
  });
  return obj;
}
/** Creates a date object offset by a specified number of days. */
Generates a random email address with a specified domain.
@return {string} A randomly generated email address.

export function dummyDate(daysOffset: number = 0): Date {
  const date = new Date();
  date.setDate(date.getDate() + daysOffset);
  return date;
}
/** Generates a random email address with a specified domain. */
Generates a random ID string with a specified prefix.
@param {string} prefix - The prefix for the generated ID.
@return {string} A randomly generated ID string.

export function dummyEmail(domain: string = 'test.com'): string {
  Returns a null value.

@returns {null} Always returns null.
  return `user_${Math.random().toString(36).substring(7)}@${domain}`;
}
/** Generates a random ID string with a specified prefix. */

Returns an undefined value.

@returns {undefined} Always returns undefined.
export function dummyId(prefix: string = 'id'): string {
  return `${prefix}_${Math.random().toString(36).substring(2, 15)}`;
}
/** Returns a random boolean value. */

export function dummyBoolean(): boolean {
  return Math.random() >= 0.5;
}
/** Returns a null value. */

export function dummyNull(): null {
  return null;
}
/** Returns an undefined value. */

export function dummyUndefined(): undefined {
  return undefined;
}
/** Returns a promise that resolves to a specified value after a delay. */

export function dummyPromise<T>(value: T, delay: number = 0): Promise<T> {
  return new Promise(resolve => {
    setTimeout(() => resolve(value), delay);
  });
}
/** Returns a function that returns a specified value. */

export function dummyFunction<T = any>(returnValue: T = undefined as T): (...args: any[]) => T {
  return () => returnValue;
}
/** Returns an async function that resolves to a specified value after a delay. */

export function dummyAsyncFunction<T = any>(returnValue: T = undefined as T, delay: number = 0): (...args: any[]) => Promise<T> {
  return async () => {
    await new Promise(resolve => setTimeout(resolve, delay));
    return returnValue;
  };
Generates a nested object with specified depth and width.
@param {number} depth - The depth of the nested object.
@param {number} width - The width at each nesting level.
@return {Object} A nested object.
/** Creates an Error object with a specified message. */
}

export function dummyError(message: string = 'Dummy error'): Error {
  return new Error(message);
/** Creates a dummy user object with generated id, name, and email. */
}

export function dummyUser(id?: string): { id: string; name: string; email: string } {
  return {
    id: id || dummyId('user'),
    name: dummyString(8),
    /** Creates a list of specified count, each element generated by a function. */
    email: dummyEmail(),
  };
}

Generates a nested object with specified depth and width.

Generates a random UUID.
@return {string} A randomly generated UUID.
@returns {Object} The generated nested object.
/** Generates a nested object with specified depth and width. */
export function dummyList<T>(count: number, generator: () => T): T[] {
  return Array.from({ length: count }, generator);
}

export function dummyNestedObject(depth: number = 2, width: number = 3): any {
  if (depth === 0) {
    return dummyString(5);
  }
  const obj: any = {};
  Generates a random hex color string.
@return {string} A randomly generated hex color code.
  for (let i = 0; i < width; i++) {
    /** Generates a random URL with specified domain and path. */
    obj[`key_${i}`] = dummyNestedObject(depth - 1, width);
  }
  return obj;
}
/** Generates a random US phone number. */

Generates a placeholder image URL with specified dimensions.
@param {number} width - The width of the image.
@param {number} height - The height of the image.
@return {string} A placeholder image URL.
export function dummyUrl(domain: string = 'example.com', path: string = ''): string {
  return `https://${domain}${path || '/' + dummyString(5)}`;
}
/** Generates a random UUID. */

 * Generates a nested object with specified depth and width.
 * @param {number} depth - The depth of the nested object.
 * @param {number} width - The width of each level in the nested object.
 * @returns {object} The generated nested object.
 Converts an object to a JSON string.
@param {Object} obj - The object to convert.
@return {string} A JSON string representation of the object.
 

export function dummyPhoneNumber(): string {
  return `+1${Math.floor(Math.random() * 9000000000) + 1000000000}`;
}

export function dummyUuid(): string {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
    /** Generates a random hex color string. */
    Encodes a string to Base64.
@param {string} str - The string to encode.
@return {string} The Base64 encoded string.
    const r = Math.random() * 16 | 0;
    
 * Generates a random UUID.
 * @returns {string} A randomly generated UUID.
 
    const v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
/** Generates a placeholder image URL with specified dimensions. */
}

export function dummyColor(): string {
  
 * Generates a random hex color string.
 * @returns {string} A random hex color (e.g., #FFFFFF).
 
  return `#${Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0')}`;
/** Converts an object to a JSON string. */
}

export function dummyImageUrl(width: number = 200, height: number = 200): string {
  
 * Generates a placeholder image URL with specified dimensions.
 * @param {number} width - The width of the image.
 * @param {number} height - The height of the image.
 * @returns {string} A placeholder image URL.
 
  return `https://via.placeholder.com/${width}x${height}`;
/** Encodes a string to Base64. */
}

export function dummyJsonString(obj: any = { test: 'value' }): string {
  
 * Converts an object to a JSON string.
 Retries a function up to a maximum number of attempts.
@param {Function} fn - The function to retry.
@param {number} attempts - The maximum number of attempts.
@return {Promise} A promise that resolves to the result of the function.
 * @param {object} obj - The object to convert.
 * @returns {string} The JSON string representation of the object.
 
  return JSON.stringify(obj);
/** Returns a promise that resolves after a specified delay. */
}

export function dummyBase64(data: string = 'test'): string {
  
 * Encodes a string to Base64.
 * @param {string} input - The string to encode.
 * @returns {string} The Base64 encoded string.
 
  return btoa(data);
/** Retries a function up to a maximum number of attempts. */
}

 * Retries a function up to a maximum number of attempts.
 * @param fn - The function to retry.
 Executes a function with a timeout, rejecting if it exceeds max time.
@param {Function} fn - The function to execute.
@param {number} maxTime - The maximum time in milliseconds.
@return {Promise} A promise that resolves or rejects based on the function execution.
 * @param maxAttempts - The maximum number of retry attempts.
 * @returns The result of the function after successful attempts.
 

export function dummyDelay(ms: number = 100): Promise<void> {
  
 * Returns a promise that resolves after a specified delay.
 * @param {number} ms - The delay in milliseconds.
 * @returns {Promise<void>} A promise that resolves after the delay.
 
  return new Promise(resolve => setTimeout(resolve, ms));
}

export function dummyRetry<T>(fn: () => T | Promise<T>, maxAttempts: number = 3): Promise<T> {
  return new Promise(async (resolve, reject) => {
    
 * Retries a function up to a maximum number of attempts.
 * @param {function} fn - The function to retry.
 * @param {number} attempts - The maximum number of attempts.
 Debounces a function, ensuring it's called after a delay.
@param {Function} fn - The function to debounce.
@param {number} delay - The time to wait before calling the function.
@return {Function} The debounced function.
 * @returns {Promise<any>} A promise that resolves to the function's result.
 
    let lastError: any;
    for (let i = 0; i < maxAttempts; i++) {
      try {
        
 * Executes a function with a timeout, rejecting if it exceeds max time.
 * @param fn - The function to execute.
 * @param ms - The maximum time in milliseconds before rejection.
 * @returns A promise that resolves with the function result.
 
        /** Executes a function with a timeout, rejecting if it exceeds max time. */
        const result = await fn();
        return resolve(result);
      } catch (error) {
        lastError = error;
      }
    }
    reject(lastError);
  /** Debounces a function, ensuring it's called after a delay. */
  });
Memoizes a function, caching its results for identical inputs.
@param {Function} fn - The function to memoize.
@return {Function} The memoized function.
}

 * Executes a function with a timeout, rejecting if it exceeds max time.
 * @param {function} fn - The function to execute.
 * @param {number} ms - The maximum execution time in milliseconds.
 * @returns {Promise<any>} A promise that resolves or rejects based on the function's execution.
 

export function dummyTimeout<T>(fn: () => T | Promise<T>, ms: number = 1000): Promise<T> {
  return Promise.race([
    Promise.resolve(fn()),
    
 * Debounces a function, ensuring it's called after a delay.
 * @param fn - The function to debounce.
 * @param delay - The time delay in milliseconds for debouncing.
 * @returns A debounced version of the function.
 
    Ensures a function is called once, returning its result for subsequent calls.
@param {Function} fn - The function to call once.
@return {Function} A function that returns the first call's result.
    new Promise<T>((_, reject) => 
      setTimeout(() => reject(new Error('Timeout')), ms)
    /** Throttles a function, limiting how frequently it can be executed. */
    
 * Debounces a function, ensuring it's called after a delay.
 * @param {function} fn - The function to debounce.
 * @param {number} delay - The debounce delay in milliseconds.
 * @returns {function} The debounced version of the function.
 
    )
  ]);
}

export function dummyDebounce<T extends (...args: any[]) => any>(
  fn: T,
  delay: number = 300
/** Memoizes a function, caching its results for identical inputs. */

 * Throttles a function, limiting how frequently it can be executed.
 * @param fn - The function to throttle.
 * @param limit - The time limit in milliseconds for throttling.
 * @returns A throttled version of the function.
 
): (...args: Parameters<T>) => void {
  let timeoutId: NodeJS.Timeout;
  return (...args: Parameters<T>) => {
    
 * Throttles a function, limiting how frequently it can be executed.
 Passes through an argument while executing a function with it.
@param {Function} fn - The function to execute.
@return {Function} A function that executes the given function with the argument.
 * @param {function} fn - The function to throttle.
 * @param {number} limit - The time in milliseconds to wait between calls.
 * @returns {function} The throttled version of the function.
 
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => fn(...args), delay);
  };
}

export function dummyThrottle<T extends (...args: any[]) => any>(
  /** Ensures a function is called once, returning its result for subsequent calls. */
  A no-operation function that does nothing.
@return {Function} A function that performs no operation.
  fn: T,
  limit: number = 300
): (...args: Parameters<T>) => void {
  
 * Memoizes a function, caching its results for identical inputs.
 * @param fn - The function to memoize.
 Returns the value passed to it.
@param {any} value - The value to return.
@return {any} The input value.
 * @returns A memoized version of the function.
 
  let inThrottle: boolean;
  return (...args: Parameters<T>) => {
    
 * Memoizes a function, caching its results for identical inputs.
 * @param {function} fn - The function to memoize.
 * @returns {function} The memoized version of the function.
 
    if (!inThrottle) {
      fn(...args);
      inThrottle = true;
      /** Creates a pipeline of functions, passing the result from one to the next. */
      Returns a function that always returns a specified value.
@param {any} value - The constant value to return.
@return {Function} A function that always returns the specified value.
      setTimeout(() => inThrottle = false, limit);
    }
  };
}
/** Composes a series of functions, executing them right to left. */

export function dummyMemoize<T extends (...args: any[]) => any>(fn: T): T {
  
 * Ensures a function is called once, returning its result for subsequent calls.
 Returns a function that always returns a specified value for any input.
@param {any} value - The value to always return.
@return {Function} A function that returns the specified value.
 * @param fn - The function to call once.
 * @returns The result of the function.
 
  const cache = new Map();
  return ((...args: Parameters<T>) => {
    /** Passes through an argument while executing a function with it. */
    const key = JSON.stringify(args);
    if (cache.has(key)) {
      return cache.get(key);
    
 * Ensures a function is called once, returning its result for subsequent calls.
 * @param {function} fn - The function to call once.
 * @returns {function} A function that returns the result of the first call.
 
    }
    const result = fn(...args);
    cache.set(key, result);
    /** A no-operation function that does nothing. */
    return result;
  }) as T;
}
/** Returns the value passed to it. */

export function dummyOnce<T extends (...args: any[]) => any>(fn: T): T {
  let called = false;
  
 * Creates a pipeline of functions, passing the result from one to the next.
 * @param fns - An array of functions to compose into a pipeline.
 * @returns A new function that executes the pipeline.
 
  let result: ReturnType<T>;
  /** Returns a function that always returns a specified value. */
  return ((...args: Parameters<T>) => {
    
 * Creates a pipeline of functions, passing the result from one to the next.
 * @param {...function} funcs - The functions to include in the pipeline.
 * @returns {function} A function that, when called, executes the pipeline.
 
 * Composes a series of functions, executing them right to left.
 * @param fns - An array of functions to compose.
 * @returns A new function that executes the composition.
 
 
    if (!called) {
      called = true;
      result = fn(...args);
    /** Returns a function that always returns a specified value for any input. */
    }
    
 * Composes a series of functions, executing them right to left.
 * @param {...function} funcs - The functions to compose.
 
 * Passes through an argument while executing a function with it.
 * @param fn - The function to execute with the argument.
 * @returns A function that executes the given function with the argument.
 
 * @returns {function} A function that, when called, executes the composed functions.
 
    return result;
  }) as T;
}
/** Function that never returns and always throws an error. */


 * Passes through an argument while executing a function with it.
 * @param {function} fn - The function to execute with the argument.
 * @returns {function} A function that passes through its argument and executes the input function.
 

 * A no-operation function that does nothing.
 * @returns void
 
export function dummyPipe<T>(...fns: Array<(arg: T) => T>): (arg: T) => T {
  return (arg: T) => fns.reduce((acc, fn) => fn(acc), arg);
}

/** Returns void, performing no operation. */
export function dummyCompose<T>(...fns: Array<(arg: T) => T>): (arg: T) => T {
  return (arg: T) => fns.reduceRight((acc, fn) => fn(acc), arg);
}

 
 * Returns the value passed to it.
 * @param value - The value to return.
 * @returns The input value.
 
 * A no-operation function that does nothing.
 * @returns {void} This function does not return a value.
 
/** Returns an empty array. */

export function dummyTap<T>(fn: (arg: T) => void): (arg: T) => T {
  return (arg: T) => {
    
 
 * Returns a function that always returns a specified value.
 * @param value - The constant value to return.
 * @returns A function that returns the constant value.
 
 * Returns the value passed to it.
 * @param {any} value - The value to return.
 * @returns {any} The same value that was passed in.
 
    /** Returns an empty object. */
    fn(arg);
    return arg;
  
 * Returns a function that always returns a specified value for any input.
 * @param value - The value to always return.
 * @returns A function that returns the specified value.
 
  };
/** Returns an empty string. */
}

 * Returns a function that always returns a specified value.
 * @param {any} value - The value to always return.
 
 * Function that never returns and always throws an error.
 * @throws An error every time it's called.
 
 * @returns {function} A function that returns the specified value.
 

export function dummyNoop(): void {
/** Returns zero. */
}


 * Returns a function that always returns a specified value for any input.
 * @param {any} value - The value to always return.
 
 * Returns void, performing no operation.
 * @returns void
 
 * @returns {function} A function that returns the specified value regardless of input.
 
export function dummyIdentity<T>(value: T): T {
  /** Returns one. */
  return value;
}


 * Returns an empty array.
 * @returns An empty array.
 

 * Function that never returns and always throws an error.
 * @throws {Error} Throws an error when called.
 
/** Returns true. */

 * Returns an empty object.
 * @returns An empty object.
 
export function dummyConstant<T>(value: T): () => T {
  return () => value;
}
/** Returns false. */

 
 * Returns an empty string.
 * @returns An empty string.
 
 * Returns void, performing no operation.
 * @returns {void} This function does not return a value.
 

 * Returns zero.
 * @returns The integer zero.
 

export function dummyAlways<T>(value: T): (...args: any[]) => T {
  return () => value;

 * Returns one.
 * @returns The integer one.
 

 * Returns an empty array.
 * @returns {Array} An empty array.
 
 * Returns true.
 * @returns The boolean true.
 
 
}


 * Returns false.
 * @returns The boolean false.
 
export function dummyNever(): (...args: any[]) => never {
  
 * Returns an empty object.
 * @returns {object} An empty object.
 
  return () => {
    throw new Error('This function never returns');
  };

 * Returns an empty string.
 * @returns {string} An empty string.
 
}

export function dummyVoid(): void {
  
 * Returns zero.
 * @returns {number} The number zero.
 
  return undefined;
}


 * Returns one.
 * @returns {number} The number one.
 
export function dummyEmptyArray<T>(): T[] {
  return [];
}

 * Returns true.
 * @returns {boolean} The boolean value true.
 

export function dummyEmptyObject(): Record<string, never> {
  return {};

 * Returns false.
 * @returns {boolean} The boolean value false.
 
}

export function dummyEmptyString(): string {
  return '';
}

export function dummyZero(): number {
  return 0;
}

export function dummyOne(): number {
  return 1;
}

export function dummyTrue(): boolean {
  return true;
}

export function dummyFalse(): boolean {
  return false;
}
