/** Generates a string of specified length filled with 'x' characters. */
export function dummyString(length: number = 10): string {
  return 'x'.repeat(length);
}

/** Generates a random number between specified min and max values. */
export function dummyNumber(min: number = 0, max: number = 100): number {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

/** Creates an array of specified length, filling it with generated elements. */
export function dummyArray<T>(length: number, generator: (index: number) => T): T[] {
  return Array.from({ length }, (_, i) => generator(i));
}

/** Creates an object with specified keys and dummy values. */
export function dummyObject(keys: string[]): Record<string, any> {
  const obj: Record<string, any> = {};
  keys.forEach(key => {
    obj[key] = `value_${key}`;
  });
  return obj;
}
/** Creates a date object offset by a specified number of days. */

export function dummyDate(daysOffset: number = 0): Date {
  const date = new Date();
  date.setDate(date.getDate() + daysOffset);
  return date;
}
/** Generates a random email address with a specified domain. */

export function dummyEmail(domain: string = 'test.com'): string {
  return `user_${Math.random().toString(36).substring(7)}@${domain}`;
}
/** Generates a random ID string with a specified prefix. */

export function dummyId(prefix: string = 'id'): string {
  return `${prefix}_${Math.random().toString(36).substring(2, 15)}`;
}
/** Returns a random boolean value. */

export function dummyBoolean(): boolean {
  return Math.random() >= 0.5;
}
/** Returns a null value. */

export function dummyNull(): null {
  return null;
}
/** Returns an undefined value. */

export function dummyUndefined(): undefined {
  return undefined;
}
/** Returns a promise that resolves to a specified value after a delay. */

export function dummyPromise<T>(value: T, delay: number = 0): Promise<T> {
  return new Promise(resolve => {
    setTimeout(() => resolve(value), delay);
  });
}
/** Returns a function that returns a specified value. */

export function dummyFunction<T = any>(returnValue: T = undefined as T): (...args: any[]) => T {
  return () => returnValue;
}
/** Returns an async function that resolves to a specified value after a delay. */

export function dummyAsyncFunction<T = any>(returnValue: T = undefined as T, delay: number = 0): (...args: any[]) => Promise<T> {
  return async () => {
    await new Promise(resolve => setTimeout(resolve, delay));
    return returnValue;
  };
/** Creates an Error object with a specified message. */
}

export function dummyError(message: string = 'Dummy error'): Error {
  return new Error(message);
/** Creates a dummy user object with generated id, name, and email. */
}

export function dummyUser(id?: string): { id: string; name: string; email: string } {
  return {
    id: id || dummyId('user'),
    name: dummyString(8),
    /** Creates a list of specified count, each element generated by a function. */
    email: dummyEmail(),
  };
}

/** Generates a nested object with specified depth and width. */
export function dummyList<T>(count: number, generator: () => T): T[] {
  return Array.from({ length: count }, generator);
}

export function dummyNestedObject(depth: number = 2, width: number = 3): any {
  if (depth === 0) {
    return dummyString(5);
  }
  const obj: any = {};
  for (let i = 0; i < width; i++) {
    /** Generates a random URL with specified domain and path. */
    obj[`key_${i}`] = dummyNestedObject(depth - 1, width);
  }
  return obj;
}
/** Generates a random US phone number. */

export function dummyUrl(domain: string = 'example.com', path: string = ''): string {
  return `https://${domain}${path || '/' + dummyString(5)}`;
}
/** Generates a random UUID. */

export function dummyPhoneNumber(): string {
  return `+1${Math.floor(Math.random() * 9000000000) + 1000000000}`;
}

export function dummyUuid(): string {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
    /** Generates a random hex color string. */
    const r = Math.random() * 16 | 0;
    const v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
/** Generates a placeholder image URL with specified dimensions. */
}

export function dummyColor(): string {
  return `#${Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0')}`;
/** Converts an object to a JSON string. */
}

export function dummyImageUrl(width: number = 200, height: number = 200): string {
  return `https://via.placeholder.com/${width}x${height}`;
/** Encodes a string to Base64. */
}

export function dummyJsonString(obj: any = { test: 'value' }): string {
  return JSON.stringify(obj);
/** Returns a promise that resolves after a specified delay. */
}

export function dummyBase64(data: string = 'test'): string {
  return btoa(data);
/** Retries a function up to a maximum number of attempts. */
}

export function dummyDelay(ms: number = 100): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

export function dummyRetry<T>(fn: () => T | Promise<T>, maxAttempts: number = 3): Promise<T> {
  return new Promise(async (resolve, reject) => {
    let lastError: any;
    for (let i = 0; i < maxAttempts; i++) {
      try {
        /** Executes a function with a timeout, rejecting if it exceeds max time. */
        const result = await fn();
        return resolve(result);
      } catch (error) {
        lastError = error;
      }
    }
    reject(lastError);
  /** Debounces a function, ensuring it's called after a delay. */
  });
}

export function dummyTimeout<T>(fn: () => T | Promise<T>, ms: number = 1000): Promise<T> {
  return Promise.race([
    Promise.resolve(fn()),
    new Promise<T>((_, reject) => 
      setTimeout(() => reject(new Error('Timeout')), ms)
    /** Throttles a function, limiting how frequently it can be executed. */
    )
  ]);
}

export function dummyDebounce<T extends (...args: any[]) => any>(
  fn: T,
  delay: number = 300
/** Memoizes a function, caching its results for identical inputs. */
): (...args: Parameters<T>) => void {
  let timeoutId: NodeJS.Timeout;
  return (...args: Parameters<T>) => {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => fn(...args), delay);
  };
}

export function dummyThrottle<T extends (...args: any[]) => any>(
  /** Ensures a function is called once, returning its result for subsequent calls. */
  fn: T,
  limit: number = 300
): (...args: Parameters<T>) => void {
  let inThrottle: boolean;
  return (...args: Parameters<T>) => {
    if (!inThrottle) {
      fn(...args);
      inThrottle = true;
      /** Creates a pipeline of functions, passing the result from one to the next. */
      setTimeout(() => inThrottle = false, limit);
    }
  };
}
/** Composes a series of functions, executing them right to left. */

export function dummyMemoize<T extends (...args: any[]) => any>(fn: T): T {
  const cache = new Map();
  return ((...args: Parameters<T>) => {
    /** Passes through an argument while executing a function with it. */
    const key = JSON.stringify(args);
    if (cache.has(key)) {
      return cache.get(key);
    }
    const result = fn(...args);
    cache.set(key, result);
    /** A no-operation function that does nothing. */
    return result;
  }) as T;
}
/** Returns the value passed to it. */

export function dummyOnce<T extends (...args: any[]) => any>(fn: T): T {
  let called = false;
  let result: ReturnType<T>;
  /** Returns a function that always returns a specified value. */
  return ((...args: Parameters<T>) => {
    if (!called) {
      called = true;
      result = fn(...args);
    /** Returns a function that always returns a specified value for any input. */
    }
    return result;
  }) as T;
}
/** Function that never returns and always throws an error. */

export function dummyPipe<T>(...fns: Array<(arg: T) => T>): (arg: T) => T {
  return (arg: T) => fns.reduce((acc, fn) => fn(acc), arg);
}

/** Returns void, performing no operation. */
export function dummyCompose<T>(...fns: Array<(arg: T) => T>): (arg: T) => T {
  return (arg: T) => fns.reduceRight((acc, fn) => fn(acc), arg);
}
/** Returns an empty array. */

export function dummyTap<T>(fn: (arg: T) => void): (arg: T) => T {
  return (arg: T) => {
    /** Returns an empty object. */
    fn(arg);
    return arg;
  };
/** Returns an empty string. */
}

export function dummyNoop(): void {
/** Returns zero. */
}

export function dummyIdentity<T>(value: T): T {
  /** Returns one. */
  return value;
}

/** Returns true. */
export function dummyConstant<T>(value: T): () => T {
  return () => value;
}
/** Returns false. */

export function dummyAlways<T>(value: T): (...args: any[]) => T {
  return () => value;
}

export function dummyNever(): (...args: any[]) => never {
  return () => {
    throw new Error('This function never returns');
  };
}

export function dummyVoid(): void {
  return undefined;
}

export function dummyEmptyArray<T>(): T[] {
  return [];
}

export function dummyEmptyObject(): Record<string, never> {
  return {};
}

export function dummyEmptyString(): string {
  return '';
}

export function dummyZero(): number {
  return 0;
}

export function dummyOne(): number {
  return 1;
}

export function dummyTrue(): boolean {
  return true;
}

export function dummyFalse(): boolean {
  return false;
}
